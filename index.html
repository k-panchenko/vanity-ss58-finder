<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vanity SS58 Finder (Browser)</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 780px;
      margin: 1.5rem auto;
      padding: 0 1rem 3.25rem; /* extra bottom space so fixed footer never covers content */
    }
    h1 { margin-bottom: 0.2rem; }
    p.subtitle { color: #555; margin-top: 0; margin-bottom: 1.1rem; }
    label { display: block; margin-top: 0.5rem; font-weight: 600; }
    input, select { width: 100%; padding: 0.4rem; margin-top: 0.25rem; box-sizing: border-box; }
    input[type="checkbox"] { width: auto; padding: 0; margin: 0; }
    button { margin-top: 1rem; padding: 0.6rem 1.4rem; font-weight: 600; cursor: pointer; }
    .row { display: flex; gap: 0.75rem 1rem; flex-wrap: wrap; }
    .row > div { flex: 1 1 200px; }
    .result, .error, .status { margin-top: 1.25rem; padding: 1rem; border-radius: 6px; }
    .result { background: #e6ffed; border: 1px solid #34c759; }
    .error { background: #ffecec; border: 1px solid #ff3b30; }
    .status { background: #f4f4f4; border: 1px solid #ddd; font-size: 0.9rem; color: #333; }
    code { background: #f4f4f4; padding: 0.15rem 0.3rem; border-radius: 3px; word-break: break-all; }
    code.copyable {
      cursor: pointer;
      position: relative;
      padding-right: 0.8rem;
    }
    code.copyable::after {
      content: '⧉';
      position: absolute;
      right: 0.15rem;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.75em;
      color: #777;
    }
    code.copyable:hover::after {
      color: #111;
    }
    .inline-label {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      margin-top: 0.5rem;
      font-weight: 600;
    }

    .footer {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      font-size: 0.85rem;
      color: #666;
      border-top: 1px solid #ddd;
      padding: 0.5rem 1rem;
      background: #fff;
      box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.03);
      text-align: right;
    }

    @media (max-width: 640px) {
      body {
        margin: 1rem auto;
        padding: 0 0.75rem 1.5rem;
      }

      /* Stack fields without extra flex spacing on small screens */
      .row {
        display: block;
      }

      .row > div {
        margin-top: 0;
      }

      label {
        margin-top: 0.4rem;
      }

      button {
        margin-top: 0.75rem;
      }
    }
  </style>
</head>
<body>
  <h1>Vanity SS58 Finder</h1>
  <p class="subtitle">Runs fully in your browser using sr25519 and SS58 (no backend).</p>

  <form id="vanity-form">
    <div class="row">
      <div>
        <label for="mode">Match mode</label>
        <select id="mode" name="mode">
          <option value="endswith">endswith</option>
          <option value="contains">contains</option>
        </select>
      </div>
      <div>
        <label for="ss58-format">SS58 format</label>
        <input id="ss58-format" name="ss58Format" type="number" value="42" min="0" />
      </div>
    </div>

    <label for="targets">Targets (comma-separated, e.g. LOL, TAO, xyz)</label>
    <input id="targets" name="targets" placeholder="LOL, XYZ, TAO" value="LOL" />
    <p style="margin-top: 0.25rem; font-size: 0.9rem; color: #555;">
      Multiple targets are treated as alternatives: the search stops on the first address that matches <em>any</em> of the comma-separated values.
    </p>

    <label class="inline-label">
      <input type="checkbox" id="match-case" name="matchCase" />
      <span>Match case</span>
    </label>

    <label for="max-tries">Max tries</label>
    <input id="max-tries" name="maxTries" type="number" value="1000000" min="1" />
    <p style="margin-top: 0.25rem; font-size: 0.9rem; color: #555;">
      Matching substrings longer than about 3 characters can require many attempts. Increase this value if you are searching for longer patterns and expect the search to run longer.
    </p>

    <button type="submit">Start search</button>
  </form>

  <div id="status" class="status" style="display:none;"></div>
  <div id="result" class="result" style="display:none;"></div>
  <div id="error" class="error" style="display:none;"></div>

  <footer class="footer">
    <strong>Author:</strong> Kostiantyn Panchenko ·
    <a href="https://github.com/k-panchenko/vanity-ss58-finder" target="_blank" rel="noopener noreferrer">
      GitHub repository
    </a>
  </footer>

  <!-- UMD bundles: define globals polkadotUtil & polkadotUtilCrypto -->
  <script src="https://unpkg.com/@polkadot/util@14.0.1/bundle-polkadot-util.js"></script>
  <script src="https://unpkg.com/@polkadot/util-crypto@14.0.1/bundle-polkadot-util-crypto.js"></script>

  <script>
    function toHex(u8a) {
      return Array.from(u8a).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function matchesTarget(addr, targets, mode, matchCase) {
      const source = matchCase ? addr : addr.toLowerCase();
      for (const t of targets) {
        const target = matchCase ? t : t.toLowerCase();
        if (mode === 'endswith') {
          if (source.endsWith(target)) return t;
        } else if (mode === 'contains') {
          if (source.includes(target)) return t;
        }
      }
      return null;
    }

    (async function init() {
      const form = document.getElementById('vanity-form');
      const statusEl = document.getElementById('status');
      const resultEl = document.getElementById('result');
      const errorEl = document.getElementById('error');

      statusEl.style.display = 'block';
      statusEl.textContent = 'Initializing crypto (WASM)…';

      function renderMatch(info, ss58Format) {
        const shareQuery = `?seed=${encodeURIComponent(info.seedHex)}&format=${encodeURIComponent(
          String(ss58Format)
        )}`;

        statusEl.style.display = 'none';
        errorEl.style.display = 'none';
        resultEl.style.display = 'block';
        resultEl.innerHTML = `
          <h2>Match found</h2>
          <p><strong>SS58 address:</strong> <code class="copyable" data-copy-label="SS58 address">${info.address}</code></p>
          <p><strong>Public key (hex):</strong> <code class="copyable" data-copy-label="public key">${info.publicKeyHex}</code></p>
          <p><strong>Seed (hex, 32 bytes):</strong> <code class="copyable" data-copy-label="seed">${info.seedHex}</code></p>
          <p><strong>Total tries:</strong> ${info.tries}</p>
          <p><strong>Elapsed:</strong> ${info.elapsedSec}s</p>
          <p><strong>Rate:</strong> ${info.rate} tries/sec</p>
          <p style="margin-top: 0.5rem; font-size: 0.9rem;">
            <strong>Share link:</strong>
            <a href="${shareQuery}">open sharable link</a>
          </p>
          <p style="margin-top: 0.5rem; font-size: 0.9rem;">
            For Bittensor usage, see
            <a href="https://github.com/k-panchenko/vanity-ss58-finder/blob/main/HOWTO_USE_GENERATED_SEED_BITTENSOR.md" target="_blank" rel="noopener noreferrer">
              How to use the generated seed
            </a>.
          </p>
        `;
      }

      function showSharedResultFromUrl() {
        let params = null;

        const search = window.location.search || '';
        const hash = window.location.hash || '';

        if (search.includes('seed=')) {
          params = new URLSearchParams(search.replace(/^\?/, ''));
        } else if (hash.includes('seed=')) {
          params = new URLSearchParams(hash.replace(/^#/, ''));
        } else {
          return;
        }

        const seedHexParam = params.get('seed');
        if (!seedHexParam) {
          return;
        }

        const ss58FormatRaw = params.get('format') || '42';
        const ss58Format = parseInt(ss58FormatRaw, 10);

        try {
          const normalized = seedHexParam.startsWith('0x') ? seedHexParam : `0x${seedHexParam}`;
          const seedU8a = polkadotUtil.hexToU8a(normalized);
          if (seedU8a.length !== 32) {
            throw new Error('Seed must be 32 bytes');
          }
          const pair = polkadotUtilCrypto.sr25519PairFromSeed(seedU8a);
          const address = polkadotUtilCrypto.encodeAddress(pair.publicKey, ss58Format);

          const info = {
            mode: 'shared',
            target: '(from seed link)',
            address,
            publicKeyHex: toHex(pair.publicKey),
            seedHex: normalized,
            tries: '-',
            elapsedSec: '-',
            rate: '-'
          };

          renderMatch(info, ss58Format);
        } catch (e) {
          statusEl.style.display = 'none';
          resultEl.style.display = 'none';
          errorEl.style.display = 'block';
          errorEl.textContent = 'Invalid seed provided in URL.';
        }
      }

      try {
        await polkadotUtilCrypto.cryptoWaitReady();
        statusEl.textContent = 'Crypto ready. Configure your search and click "Start search".';
      } catch (e) {
        statusEl.style.display = 'none';
        errorEl.style.display = 'block';
        errorEl.textContent = 'Failed to initialize crypto: ' + (e && e.message ? e.message : e);
        return;
      }

      // Click-to-copy for values in the result panel.
      resultEl.addEventListener('click', async (event) => {
        const target = event.target.closest('.copyable');
        if (!target) return;

        const value = (target.textContent || '').trim();
        if (!value) return;

        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(value);
          } else {
            const textarea = document.createElement('textarea');
            textarea.value = value;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
          }

          const label = target.getAttribute('data-copy-label') || 'value';
          statusEl.style.display = 'block';
          statusEl.textContent = `Copied ${label} to clipboard.`;
          setTimeout(() => {
            if (statusEl.textContent.startsWith('Copied ')) {
              statusEl.style.display = 'none';
            }
          }, 1500);
        } catch (e) {
          // Silent failure; no need to interrupt the user.
        }
      });

      // If a seed is provided in the URL (for sharing), show its result immediately.
      showSharedResultFromUrl();

      form.addEventListener('submit', async (event) => {
        event.preventDefault();
        resultEl.style.display = 'none';
        errorEl.style.display = 'none';

        const mode = document.getElementById('mode').value || 'endswith';
        const targetsRaw = document.getElementById('targets').value || '';
        const ss58FormatRaw = document.getElementById('ss58-format').value || '42';
        const maxTriesRaw = document.getElementById('max-tries').value || '50000';
        const matchCase = document.getElementById('match-case').checked;

        const targets = targetsRaw.split(',').map(t => t.trim()).filter(Boolean);
        const ss58Format = parseInt(ss58FormatRaw, 10);
        const maxTries = parseInt(maxTriesRaw, 10);

        if (!['contains', 'endswith'].includes(mode)) {
          errorEl.style.display = 'block';
          errorEl.textContent = "Mode must be 'contains' or 'endswith'.";
          return;
        }
        if (!targets.length) {
          errorEl.style.display = 'block';
          errorEl.textContent = 'Please provide at least one target substring.';
          return;
        }
        if (!Number.isFinite(maxTries) || maxTries <= 0) {
          errorEl.style.display = 'block';
          errorEl.textContent = 'Max tries must be a positive number.';
          return;
        }

        statusEl.style.display = 'block';
        statusEl.textContent = 'Searching…';

        let tries = 0;
        const start = performance.now();
        let hitInfo = null;

        const chunkSize = 1000;

        async function runChunk() {
          const endFor = Math.min(tries + chunkSize, maxTries);
          for (; tries < endFor; tries++) {
            const seed = polkadotUtilCrypto.randomAsU8a(32);
            const pair = polkadotUtilCrypto.sr25519PairFromSeed(seed);
            const address = polkadotUtilCrypto.encodeAddress(pair.publicKey, ss58Format);
            const hit = matchesTarget(address, targets, mode, matchCase);

            if (hit) {
              const elapsedMs = performance.now() - start;
              const triesPerSec = tries / (elapsedMs / 1000 || 1);

              hitInfo = {
                mode,
                target: hit,
                address,
                publicKeyHex: toHex(pair.publicKey),
                seedHex: toHex(seed),
                tries,
                elapsedSec: (elapsedMs / 1000).toFixed(2),
                rate: triesPerSec.toFixed(1)
              };
              return;
            }
          }

          const elapsedMs = performance.now() - start;
          const triesPerSec = tries / (elapsedMs / 1000 || 1);
          statusEl.textContent = `Searching… tries: ${tries} — rate: ${triesPerSec.toFixed(1)} tries/sec`;

          if (tries < maxTries && !hitInfo) {
            await new Promise(resolve => setTimeout(resolve, 0));
            return runChunk();
          }
        }

        await runChunk();

        if (hitInfo) {
          renderMatch(hitInfo, ss58Format);
        } else {
          statusEl.style.display = 'none';
          errorEl.style.display = 'block';
          errorEl.textContent = `No match found in ${maxTries} tries.`;
        }
      });
    })();
  </script>
</body>
</html>

